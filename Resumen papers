1)Programming as Theory Building
Una corriente de definicion de la programacion la clasifica como la produccion de un programa y ciertos otros textos, pero la practica demuestra que esta consideracion puede
ser errada sobre todo en el surgimiento de errores de ejecucion y/o de reacciones, asi como en la modificacion de estos programas.
La alternativa a esta definicion propone que la programacion es una actividad mediante la cual los programadores pueden ganar comprension o teorizar sobre los asuntos en 
cuestion.
THEORY BUILDING VIEW (teoria de la vista constructiva)
Programar: la actividad de diseñar e implementar soluciones programadas. Como consecuencia esta def. incluye que el desarrollo en tiempo 
correspondiente a los cambios que tiene lugar en la actividad de la vida real, acompañados por la ejecucion del programa (en otras palabras modificaciones del programa).
La idea principal que quiere que nos llevemos es que programar es una actividad del mundo real y no una manipulacion de simbolos hecha por una computadora.
En este sentido la programacion debe ser principalmente un conocimiento adquirido por el programador al que puede acceder como primera instancia, dejando cualquier
tipo de documentacion como una erramienta auxiliar/complementaria.
Para demostrar su punto da un ejemplo de como un grupo A desarrolla un compilador para un lenguaje y cierta computadora. Otro grupo de programadores B les compra el software,
documentacion y los procesos de elaboracion para desarrollar un compilador para una extension del lenguaje que compila el grupo A; estan en contacto constantemente con el grupo 
A y las soluciones a los problemas que plantea B no aprovechan la simpleza ni reusan lo maximo posible la pre-estructura de A (feedback de grupo A a B) y ellos proponen solucio-
nes elegantes y basadas en la reutilizacion de codigo. Moraleja: el conocimiento estaba inherente al grupo A e incluso con la documentacion, programa y demas no es posible aprender
lo mismo sobre ese programa que habiendolo desarrollado.
Ej 2: se desarrola un software gigante de 200.000 lineas de texto los cuales son vendidos e instalados/debugeados por un mismo 
equipo a lo largo de los años; esto les dio al equipo un mejor entendimiento del software que incluso dandosele la documentacion
a otros equipos de programadores no pueden resolver o no terminan de entender como evoluciona. Moraleja: no seas raton contrata
al que lo desarrollo.
Ryle's Notion of Theory (la nocion de Teoria de Ryle)
Nocion de teoria de Ryle: basicamente el conocimiento que tiene el programador debe considerarse como una teoria de conocimientos
, tecnicas sobre el asunto en cuestion. Dicha teoria deberia poder ser explicada, justificada por el programador.
Ryle difiere las actividades intelectaules de las inteligentes: las actividades inteligentes se caracterizan por tener reglas
a las que se puede adherir para ser bueno en cierta actividad, pero no es estricto seguirlas para ser bueno segun un estandar al que
la persona que desarrolla las actividades quiere seguir.
Por otro lado las actividades intelectuales, sobrepasando la actividad intelectual, precisan de una teoria que les permita no
solo realizar una actividad, si no tambien poder explicarla, justificarla, responder consultas; mientras construye su  teoria
la persona trata de entenderlas tambien.
La teoria en este contexto no puede ser considerada aislada del resto del mundo; no lacanza con enteder que una teoria
nos da un marco especifico si no que debemos poder aplicarlo de manera amplia.
En la nocion de teoria de Ryle no se puede expresar las teorias como reglas, pues las similaridades y/o patrones que la
persona que teoriza podria tomar como reglas podrian ser no mas que casualidades.
The Theory To Be Built by the Programmer(La teoria construida por el programador)
En terminos de la teoria de Ryle, lo que debe ser construido por el programador es una teoria de como ciertos aspectos
del mundo real seran manejados por un programa de computadora. En la TBV la teoria del programador debe tomar precedencia 
ante cualquier otro programa o documentacion.
La TBV argumenta que el conocimiento del programador supera a cualquier documentacion en por lo menos 3 aspectos:
1) El programador tiene el entendimiento de como se reflejan las tareas/aspectos del mundo real sobre el que se teoriza,
teniendo una relacion simetrica entre que partes estructurales del codigo reflejan partes del mundo/actividad y viceversa,
tambien sabiendo que partes del mundo real son necesarias teorizar, lo que enraiza el entendimiento y necesidad del programador.
2) El programador al tener la teoria puede justificar el diseño de el programa, siendo capaz de defender sus decisiones y
en ultima instania siendo justificadas por su conocimiento.
3) El programador debe ser capaz de actualizar el codigo existente en respuesta a cambios del mundo real, basandose en cambios 
minimos a la estructura ya existente y siendo el unico capaz de realizarlos haciendo el mejor uso de la estructura ya que fue
quien lo diseño.
PROBLEMAS Y COSTOS DE MODIFICACION DEL PROGRAMA
En la TBV el costo de modificacion del programa no puede ser comparado a otra nociones del mundo real (destruir todo y comenzar de
nuevo); tambien es falso en esta teoria que es barato modificar programas ya que son solo texto y el costo de modificarlo es
solamente el de modificarlo, lo que incurre en una falta con la definicion de programa de la teoria.
El concepto de flexibilidad se refiere a la inclusion en el programa de ciertas herramientas que no seran demandadas inmediatamente
pero al momento de serlas no sera necesario modificar el programa.
La flexibilidad no debe aparecer como solucion a la modificacion de programas pues si bien puede ser util en ciertos casos,
el desarrollo, testeo y teorizacion se basan meramente en una posibilidad futura de su uso.
En el momento de buscar la solucion optima para el problema del mundo real que se quiere añadir a la solucion programada ya
existente, se evidencia la necesidad del programador con su teoria y conocimiento de la solucion ya implementada y de la que se
debe agregar de modo que sera el quien puede aportar la mejor solucion, sin necesariamente ser capaz de pasar esta vision en 
reglas a seguir en cada ocasion.
Plantea que no existe la modificacion de teoria como tal si no la modificacion del programa y que el programador debe estar preparado para responder/teorizar sobre
estos cambios, si se lo mira como solo cambio de codigo se puede caer en el error de parchar el codigo ya que pueden haber muchas modificaciones para esta percepcion 
pero si no se amoldan a la teoria no son buenas soluciones. La simplicidad y buena estructuracion deben actuar como parametro de buena calidad a la hora de teorizar.
VIDA, MUERTE Y RESURRECCION DEL PROGRAMA (¿evangelizacion?)
Para describir el estado de un programa se precisa hablar del grupo de programadores que lo creo: cuando nace el programa se esta teorizando sobre el, va a estar 'vivo'
mientras este equipo que teorizo lo opere, mantenga y modifique, se dice que muere cuando ya no lo maneja el grupo que lo teorizo (aunque a fines practicos siga sirviendo)
y puede revivir cuando un grupo vuelve a teorizar sobre el a priori para modificarlo.Despues dice que aprendes hablando con los que hicieron el programa no con su documentacion, 
y que es mas caro tratar de revivir la teoria de un programa que permitir a un nuevo grupo hacer una nueva, incluso si se llega a formular una teoria basandose en el codigo y
tratando de resolver los mismos problemas las diferencias serian muy grandes.
CONSTRUCCION DE METODO Y TEORIA
Define un metodo como las reglas para los programadores, diciendoles que deberia hacer, en que orden, notaciones o lenguajes a usar, y que documentacion producir en que etapa.
Un metodo implica el desarrollo de codigo como algo que puede/debe ser separado en partes, como una serie de pasos; esto va en contra de la TBV ya que una teoria no se puede 
separar en etapas.Lo mismo aplica para el resto de conceptos que abarca metodos.
En la TBV no hay metodos correctos para el desarrollo de software, lo defiende de dos ataques:
1) Se deberia tratar a la programacion como tema de ciencia y por lo tanto usar metodos cientificos. 
   Defensa: asumir que hay un metodo cientifico y que seguirlo ayuda a los cientificos es errado.
2) Seguimiento de metodos usados exitosamente siendo publicado.
   No hay estudios que demuestren que seguir un metodo X lleve al exito. Lo que queda aprendido de haber usado un metodo forma al prgramador y esto es valido para la teoria,
   pero no es el valor deel metodo como tal ya que no todos se adaptan siempre.
ESTATUS DEL PROGRAMADOR Y LA TBV 
Hace enfasis en la diferencia entre la percepcion general sobre los programadores (sus mentes actuan como maquinas entonces deben ser tratados como tales y esperarse que 
respondan como una computadora, siguiendo reglas y siendo facilmente reemplazables), en un estudio de Oskarsson de 1982 sobre un sistema, incluso hablando solamente de lo tecnico
del sistema que habian vendido, se deja entre ver de manera aislada que en realidad los programadores siguen estando atras de cada decision.
En cambio la TBV ve a los programadores como los que teorizan y que son la verdadera solucion de problemas y no solo software(mas de lo mismo de antes).
CONCLUSIONES DEL TEXTO
Para adaptar el codigo a cambios que puedan surgir hay que teorizar sobre los temas a tratar/resolver de la vida real, de tal modo que el codigo pueda ejecutarlos.
Para mantener la vida util del codigo hay que tener el equipo que teorizo para crearlo.
La idea de metodos de programacion es errada y debe evitarse pues viene de ideas erradas.
El programador no debe ser tratado como algo expendible y reemplazable, si no darle su importancia pues su formacion no se basa solo en saber notaciones o lenguajes de programacion
si no en como teorizar y tener un acercamiento mas correcto a los temas a resolver
MIS CONLUSIONES
mucho texto.
El texto toca temas centrales: TBV, nocion de Ryle sobre la teoria, modificacion del programa,metodos,vida util de los programas,trato de los programadores.
En general apunta a que importa la teorizacion antes de cualquier otra cosa, lo que es un aspecto propio del programador y nadie mas puede tener si no teoriza
por si mismo.
