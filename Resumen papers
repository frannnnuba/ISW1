1)Programming as Theory Building
Una corriente de definicion de la programacion la clasifica como la produccion de un programa y ciertos otros textos, pero la practica demuestra que esta consideracion puede
ser errada sobre todo en el surgimiento de errores de ejecucion y/o de reacciones, asi como en la modificacion de estos programas.
La alternativa a esta definicion propone que la programacion es una actividad mediante la cual los programadores pueden ganar comprension o teorizar sobre los asuntos en 
cuestion.
THEORY BUILDING VIEW (teoria de la vista constructiva)
Programar: la actividad de diseñar e implementar soluciones programadas. Como consecuencia esta def. incluye que el desarrollo en tiempo 
correspondiente a los cambios que tiene lugar en la actividad de la vida real, acompañados por la ejecucion del programa (en otras palabras modificaciones del programa).
La idea principal que quiere que nos llevemos es que programar es una actividad del mundo real y no una manipulacion de simbolos hecha por una computadora.
En este sentido la programacion debe ser principalmente un conocimiento adquirido por el programador al que puede acceder como primera instancia, dejando cualquier
tipo de documentacion como una erramienta auxiliar/complementaria.
Para demostrar su punto da un ejemplo de como un grupo A desarrolla un compilador para un lenguaje y cierta computadora. Otro grupo de programadores B les compra el software,
documentacion y los procesos de elaboracion para desarrollar un compilador para una extension del lenguaje que compila el grupo A; estan en contacto constantemente con el grupo 
A y las soluciones a los problemas que plantea B no aprovechan la simpleza ni reusan lo maximo posible la pre-estructura de A (feedback de grupo A a B) y ellos proponen solucio-
nes elegantes y basadas en la reutilizacion de codigo. Moraleja: el conocimiento estaba inherente al grupo A e incluso con la documentacion, programa y demas no es posible aprender
lo mismo sobre ese programa que habiendolo desarrollado.
Ej 2: se desarrola un software gigante de 200.000 lineas de texto los cuales son vendidos e instalados/debugeados por un mismo 
equipo a lo largo de los años; esto les dio al equipo un mejor entendimiento del software que incluso dandosele la documentacion
a otros equipos de programadores no pueden resolver o no terminan de entender como evoluciona. Moraleja: no seas raton contrata
al que lo desarrollo.
Ryle's Notion of Theory (la nocion de Teoria de Ryle)
Nocion de teoria de Ryle: basicamente el conocimiento que tiene el programador debe considerarse como una teoria de conocimientos
, tecnicas sobre el asunto en cuestion. Dicha teoria deberia poder ser explicada, justificada por el programador.
Ryle difiere las actividades intelectaules de las inteligentes: las actividades inteligentes se caracterizan por tener reglas
a las que se puede adherir para ser bueno en cierta actividad, pero no es estricto seguirlas para ser bueno segun un estandar al que
la persona que desarrolla las actividades quiere seguir.
Por otro lado las actividades intelectuales, sobrepasando la actividad intelectual, precisan de una teoria que les permita no
solo realizar una actividad, si no tambien poder explicarla, justificarla, responder consultas; mientras construye su  teoria
la persona trata de entenderlas tambien.
La teoria en este contexto no puede ser considerada aislada del resto del mundo; no lacanza con enteder que una teoria
nos da un marco especifico si no que debemos poder aplicarlo de manera amplia.
En la nocion de teoria de Ryle no se puede expresar las teorias como reglas, pues las similaridades y/o patrones que la
persona que teoriza podria tomar como reglas podrian ser no mas que casualidades.
The Theory To Be Built by the Programmer(La teoria construida por el programador)
En terminos de la teoria de Ryle, lo que debe ser construido por el programador es una teoria de como ciertos aspectos
del mundo real seran manejados por un programa de computadora. En la TBV la teoria del programador debe tomar precedencia 
ante cualquier otro programa o documentacion.
La TBV argumenta que el conocimiento del programador supera a cualquier documentacion en por lo menos 3 aspectos:
1) El programador tiene el entendimiento de como se reflejan las tareas/aspectos del mundo real sobre el que se teoriza,
teniendo una relacion simetrica entre que partes estructurales del codigo reflejan partes del mundo/actividad y viceversa,
tambien sabiendo que partes del mundo real son necesarias teorizar, lo que enraiza el entendimiento y necesidad del programador.
2) El programador al tener la teoria puede justificar el diseño de el programa, siendo capaz de defender sus decisiones y
en ultima instania siendo justificadas por su conocimiento.
3) El programador debe ser capaz de actualizar el codigo existente en respuesta a cambios del mundo real, basandose en cambios 
minimos a la estructura ya existente y siendo el unico capaz de realizarlos haciendo el mejor uso de la estructura ya que fue
quien lo diseño.
PROBLEMAS Y COSTOS DE MODIFICACION DEL PROGRAMA
En la TBV el costo de modificacion del programa no puede ser comparado a otra nociones del mundo real (destruir todo y comenzar de
nuevo); tambien es falso en esta teoria que es barato modificar programas ya que son solo texto y el costo de modificarlo es
solamente el de modificarlo, lo que incurre en una falta con la definicion de programa de la teoria.
El concepto de flexibilidad se refiere a la inclusion en el programa de ciertas herramientas que no seran demandadas inmediatamente
pero al momento de serlas no sera necesario modificar el programa.
La flexibilidad no debe aparecer como solucion a la modificacion de programas pues si bien puede ser util en ciertos casos,
el desarrollo, testeo y teorizacion se basan meramente en una posibilidad futura de su uso.
En el momento de buscar la solucion optima para el problema del mundo real que se quiere añadir a la solucion programada ya
existente, se evidencia la necesidad del programador con su teoria y conocimiento de la solucion ya implementada y de la que se
debe agregar de modo que sera el quien puede aportar la mejor solucion, sin necesariamente ser capaz de pasar esta vision en 
reglas a seguir en cada ocasion.
Plantea que no existe la modificacion de teoria como tal si no la modificacion del programa y que el programador debe estar preparado para responder/teorizar sobre
estos cambios, si se lo mira como solo cambio de codigo se puede caer en el error de parchar el codigo ya que pueden haber muchas modificaciones para esta percepcion 
pero si no se amoldan a la teoria no son buenas soluciones. La simplicidad y buena estructuracion deben actuar como parametro de buena calidad a la hora de teorizar.
VIDA, MUERTE Y RESURRECCION DEL PROGRAMA (¿evangelizacion?)
Para describir el estado de un programa se precisa hablar del grupo de programadores que lo creo: cuando nace el programa se esta teorizando sobre el, va a estar 'vivo'
mientras este equipo que teorizo lo opere, mantenga y modifique, se dice que muere cuando ya no lo maneja el grupo que lo teorizo (aunque a fines practicos siga sirviendo)
y puede revivir cuando un grupo vuelve a teorizar sobre el a priori para modificarlo.Despues dice que aprendes hablando con los que hicieron el programa no con su documentacion, 
y que es mas caro tratar de revivir la teoria de un programa que permitir a un nuevo grupo hacer una nueva, incluso si se llega a formular una teoria basandose en el codigo y
tratando de resolver los mismos problemas las diferencias serian muy grandes.
CONSTRUCCION DE METODO Y TEORIA
Define un metodo como las reglas para los programadores, diciendoles que deberia hacer, en que orden, notaciones o lenguajes a usar, y que documentacion producir en que etapa.
Un metodo implica el desarrollo de codigo como algo que puede/debe ser separado en partes, como una serie de pasos; esto va en contra de la TBV ya que una teoria no se puede 
separar en etapas.Lo mismo aplica para el resto de conceptos que abarca metodos.
En la TBV no hay metodos correctos para el desarrollo de software, lo defiende de dos ataques:
1) Se deberia tratar a la programacion como tema de ciencia y por lo tanto usar metodos cientificos. 
   Defensa: asumir que hay un metodo cientifico y que seguirlo ayuda a los cientificos es errado.
2) Seguimiento de metodos usados exitosamente siendo publicado.
   No hay estudios que demuestren que seguir un metodo X lleve al exito. Lo que queda aprendido de haber usado un metodo forma al prgramador y esto es valido para la teoria,
   pero no es el valor deel metodo como tal ya que no todos se adaptan siempre.
ESTATUS DEL PROGRAMADOR Y LA TBV 
Hace enfasis en la diferencia entre la percepcion general sobre los programadores (sus mentes actuan como maquinas entonces deben ser tratados como tales y esperarse que 
respondan como una computadora, siguiendo reglas y siendo facilmente reemplazables), en un estudio de Oskarsson de 1982 sobre un sistema, incluso hablando solamente de lo tecnico
del sistema que habian vendido, se deja entre ver de manera aislada que en realidad los programadores siguen estando atras de cada decision.
En cambio la TBV ve a los programadores como los que teorizan y que son la verdadera solucion de problemas y no solo software(mas de lo mismo de antes).
CONCLUSIONES DEL TEXTO
Para adaptar el codigo a cambios que puedan surgir hay que teorizar sobre los temas a tratar/resolver de la vida real, de tal modo que el codigo pueda ejecutarlos.
Para mantener la vida util del codigo hay que tener el equipo que teorizo para crearlo.
La idea de metodos de programacion es errada y debe evitarse pues viene de ideas erradas.
El programador no debe ser tratado como algo expendible y reemplazable, si no darle su importancia pues su formacion no se basa solo en saber notaciones o lenguajes de programacion
si no en como teorizar y tener un acercamiento mas correcto a los temas a resolver
MIS CONLUSIONES
mucho texto.
El texto toca temas centrales: TBV, nocion de Ryle sobre la teoria, modificacion del programa,metodos,vida util de los programas,trato de los programadores.
En general apunta a que importa la teorizacion antes de cualquier otra cosa, lo que es un aspecto propio del programador y nadie mas puede tener si no teoriza
por si mismo.
PAPER 2 LA PSICOLOGIA DE LOS OBJETOS COTIDIANOS
Los objetos bien diseñados son
fáciles de interpretar y comprender. Contienen pistas visibles acerca de su funcionamiento. Los objetos mal diseñados pueden resultar difíciles deutilizary frustrantes.
Habla de diseño natural, esto es el empleo de señales naturales, osea el diseño debe explicarse por si mismo sin necesidad de simbolos/explicacion mas que el del uso natural
que uno le daria, interpretado por el usuario por estas señales(analogia puertas).
La visibilidad del diseño debe ser la justa: si hay de menos el usuario no va a saber donde encontrar lass funciones, y si hay de mas el usuario se abruma y no sabe utilizarlo.
Prestación en psicologia de materiales refiere en este sentido a las propiedades percibidas y efectivas del objeto.
Evitar sistemas y diseños que puedan a llegar a causar efectos por casualidad que se tomen como causalidad.
Modelos conceptuales: al ver los componentes y los elementos que sean visibles, se infiere su uso y la relacion de estos componentes en los resultados que tendra utilizar
el objeto. PRestaciones: lo que esta para usarse ; Restricciones: es el como deben ser usadas los elementos visibles para usar las  prestaciones.
principios fundamentales del diseño para la gente: 1) aportar un buen modelo conceptual, y 2) hacer que las cosas sean visibles. 
A) Aportar un buen modelo conceptual:
Un buen modelo conceptual nos permite predecir los efectos de nuestros actos. necesitamos comprender la relación entre los mandos y los resultados.
Modelo de diseño: es inherente a quien diseño el objeto.
Modelo de usuario: construccion mental del usuario respecto de como utilizar el objeto basada en la interaccion con este y posible documentacion.
Imagen del sistema: es la estructura fisica (documentacion,instrucciones,etiquetas). Es la encargada de que el usuario pueda llegar a tener el mismo modelo que el del diseñador.
Un sistema comprensible deberia ser visible, la topografia es buena, relacion entre los mandos y lo que controlan es natural, los mandos son unicos y suelen tener buena retroalimentaicon.
TOPOGRAFIA: relacion entre dos cosas; en el contexto de este paper es la relacion entre los mandos, sus desplazamientos y sus resultados.
Para el diseño sirve sobre todo la nocion de topografia natural (cultural o biologica): poder establecer un orden de mas o menos a lo que simulamos, mas brillo, menos bateria,
etc. mientras que otras topografias pueden ser sutituvas, donde se cambia un valor por otro y asi.
La relacion de mando -- resultado/funcion debe tratarse de ser uno a uno y no sobrecargar un mando a varios posibles resultados; luego si estos mandos son autodescriptibles 
aprovechando la topografia(imagenes,visuales) se resultara mas facil utilizarlos.
PRINCIPIO DE RETROALIMENTACION: envío de vuelta al usuario de información acerca de qué acto se ha realizado efectivamente y qué resultado se ha logrado.
paradoja de la tecnología: por lo general, una mayor capacidad funcional se ha de pagar con una mayor complejidad. 
Existe una correlacion entre los costes y utilidad: si se quiere mayor utilidad habra mayor coste; si cuesta menos habra menor utilidad lo que puede complicar el uso.
Un buen diseño deberia poder adaptarse a las exigencias del fabricante, vendedor, usuario y mantinimiento. Si a los 3 intentos no se establece bien el publico suele rechazar
el producto tratandolo de fallido, pero generalmente se necesita de al menos hasta 6 intentos para conseguir un lanzamiento viable.
PARADOJA DE LA TECNOLOGIA: se ve como un grafico tipo U, un diseño puede arrancar siendo complicado y dificil de entender por los usuarios, luego la dificultad baja
y parece estabilizarse temporalmente, el problema resurje cuando se le quiere agregar mas funcionalidad/potencia a los modelos ya funcionales, a costo de complejizar el
modo de usar los mandos y volver a un sistema incomprensible por el usuario (ejemplos relojes -> relojes digitales, radio viejas -> radios simples -> radios reproductoras etc).
La paradoja de la tecnologia no debe usarse para justificar un mal diseño: la paradoja de la tecnologia se da desde un modelo que pudo arrancar mal y mejoro y volvio a empeorar
a cause de los agregados; mientras que si un modelo estaba mal concevido desde un inicio no fue victima de la paradoja.

PAPER 3 NO SILVER BULLET
Habla sobre como no se puede comparar la revolucion que fueron los transistores etc en el hardware (brindando confiabilidad,simplicidad,productividad) a la produccion de software
Para hablar de las dificultades esperables en el desarrollo de software, las divide en esencia y accidentes.
Problemas de esencia: son aquellos inherentes a la naturaleza del software.
Considera que la dificultad de los problemas de esencia son la especificacion,diseño y testeo de la estructura conceptual del software y no de una representacion de esta.PAra
hablar de esto dice que hay 4 propiedades inherentes a la esencia del software:
1) Complejidad: la complejidad se entiende por la cantidad de elementos del software, como interactuan entre si, su "tamaño"y su naturaleza. Luego el querer abstraer un problema de su
complejidad no sirve para el desarrollo de software como puede servir para otras ciencias, pues en si esta la esencia del problema; de la complejidad viene el problema
de enumerar los distintos estados del programa y por ende su poca fiabilidad
2)Ajustabilidad: la complejidad viene dada tambien en cierto modo por lo reciente del software, en algunos casos debe conformarse por ser lo mas reciente en aparecer
en escena mientras que otras veces debe conformarse por ser el mas conformable. No hay una manera que el software pueda ajustarse a todo de manera integral pues cada estruc.
de software se ajusta a interfaces reales.
3)Posibilidad de cambio: el software es producto constante de cambio pues encarna su funcionalidad; el problema es que la funcionalidad es sujeto de cambio continuo ya sea 
por querer agregarsele funciones, o porque el 'vehiculo' del software cambia(pcs,discos,impresoras etc).
4)Invisibilidad: el software carece de una representacion grafica que facilite su comprension, deteccion de errores etc si bien se puede intentar con grafos dirigidos demas
no se suele conseguir la idea de abstraccion geometrica, por ende el software permanece inrepresentable privandonos de visualizar alguna de sus herramientas mas poderosas.
Menciona 3 casos que mejoraron las dificultades accidentales mas no las esenciales: lenguajes de alto nivel, time-sharing, enviroments compartidos de programacion.
Menciona la programacion orientada a objetos desde 2 enfoques: abstraccion de estructuras de datos y la otra tipos de jerarquia. Ambos enfoques permiten sacar dificultades de 
accidente mas no atacan el problema de esencia.
Menciona la IA desde dos enfoques: AI-1: uso de computadoras para resolucion de problemas previamente solo resolvibles por humanos y AI-2: uso de heuristicas programacion
basada en reglas.
AI-1: el problema de construir software no proviene de como decir las cosas si no que decir.Ademas dice que la programacion tiene algo imaginativo inherente a los humanos.
AI-2(Expert Systems): IA usada para la construccion de sistemas expertos; los sistemas expertos son un programa con un motor de inferencia generalizado y una base de reglas,
Los motores de inferencia proveen soluciones a algoritmos independientes de aplicacion y luego son aplicadas de manera especifica; la parte mutable de cada aplicacion
especifica esta embebida en la base de reglas, la cual aporta herramientas para modificacion, testeo etc de la propia aplicacion. EL autor sugiere que la mayor ventaja de 
los motores de inferencia no son de la resolucion especifica del problema si no de la complejidad de la aplicacion particular.
Criticas: para generar un sistema experto necesita de un experto del cual aprender y esto puede ser costoso; y que lo que se especifica para estos sistemas no es el problema
si no el como resolver el problema, lo cual necesita de alguien que entienda el problema.Sugiere que pueden servir para ayudar a programadores novatos a adquirir tecnicas.
Programacion visual: no sirve de nada realizar un esquema de control de flujo despues de haber hecho el programa, segundo menciona que las pantallas eran muy chicas para
mostrar el alcance de cualquier diagrama de software complejo(esto no aplica a hoy en dia? El texto es de 1986)
Problemas de accidente: problemas que afectan al desarrolo actual pero no son inherentes a la naturaleza del software.
Verificacion de programas: plantea la idea de chequear los programas antes de implementarlos; inmediatamente la rechaza pues no implica una mejora significativa, no implica
que el codigo no vaya a tener errores y no mejora el enfoque de como resolver la esencia .
Environments and tools: desprecia las ides diciendo que no aportarian mas que correctitud sintactica y semantica a menor medida. sugiere una base de datos compartida donde 
se detallen percepciones y detalles de los porgramadores para poder ser consultadas y recordadas inmediatamente.
Estaciones de trabajo: mejoras de computo son bienvenidas pero no atacan el problema princ.
Comprar VS Construir: poner en consideracion el costo de comprar software vs construirlo. Aunque inicalmente pueda parece mucho puede ser mas barato y eficiente que construir 
de cero.
Refinamiento de prerequisitos y prototipado rapido: especificar el software tiene que ser la parte mas importante que haga un diseñador de software. La mayor forma de atacar
los problemas de esencia es el desarrollo de herramientas que permitan iterar sobre los prerequisitos de la especificacion para poder construir prototipos del software
para poder ser testeado por el usuario antes de ponerse a hacer casos borde etc.
Construccion vs "Crecimiento" de software: no le gusta que digan construccion de software. Dice que el poner un sistema, por precario que sea, en funcionamiento permite ver
resultados, desde ahi mejorarlo y dar detalles(top-down).
Problemas accidentales: aquellos no inherentes a la esencia del software.

PAPER 4 SELF
Es un lenguaje orientado a objetos pero prototipado, no hay variables ni clases ni instancias,todo son objetos y mensajes que se saben responder.
Plantea que los sistemas de prototipado no tienen clases pues los objetos tienen caracs propias y basarse en un modelo a 'instanciar' le saca propiedades unicas intrinsecas
a cada objeto; los prototipos simplemente permiten copiar comportamiento y dejan lugar para cada mensaje poder ser customizado.
Para que todos los objetos sean iguales, incluso el prototipo que presenta el comportamiento, tienen un 'padre' que es el que tiene estas caracteristicas en comun y actua
como suerte de clase.Dice que el tener variables en vez de 'slots' que se autoresponden le quita peso a los mensajes y se diluye el concepto de POO.
