(DISCLAIMER NO ESTAN EN ORDEN)
FAIL FAST (Jim Shore): no hacer codigo que se consturye alrededor de errores en vez de enfrentarlos directamente, hay que hacer que falle lo antes posible 
fail-fast fundamentals: usar assertions para que salte la excepcion, si es con alguna descripcion mejor, cuando hay comentarios o te dan ganas de comentar un metodo hay que reemplazar eso por un assertion,
evitar assertions sobre un metodo especifico y hacerlo sobre como el sistema falla para ese metodo mejor.
writing assertions: hay que escribirlos lo mas cerca posible del error mismo, usa una reglas del 'pulgar' basicamente si el sistema falla rapido solo no hace nada, caso contrario lo hace fallar rapido para 
que salte la assertion.
eliminate the debugger: el mensaje del assertion deberia eliminar el uso del debugger, basicamente tenes que evitar repetir la condicion del assert y dar la suficiente info para enteder cual es el error
sin meterte al stack. No hace falta que sea user-friendly es para los programadores.
Robust failure: no temer al hacer la excepcion por miedo al cliente, se puede ir a un punto medio entre evitar esto y crashear(nunca debe pasar), algo como reportar el error y seguir ejecutando otros 
comandos o algun punto medio que le avise al programador de este error, pues se le escapo a su testing si le aparece a un usuario. Esto seria un global exception handler.
Finalmente si estas trabajando con archivos externos o cosas asi hay que asegurarse de cerrarlos mas alla de la falla, meter un global exc handler y sacar los catch exception locales, junto con
assertions es la esencia de esta tecnica de fail fast.

PATTERN ABUSER(Mahesh Dohani): arranca diciendo que era un programador ineficiente y enfocado en que tenia una funcionalidad a agregar a un sistema y se trababa
y no era bueno. Llega un compañero y le propone el Gang of Four design pattern book prometiendo ser la solucion de todo diseño y que los llevaria a "los 
sistemas bien diseñados y reutilizabilidad.El pensaba que programar y diseñar son alguna especie de opuestos, y que con estos patrones dejo de programar para
diseñar; lo que es mas se aprendio de memoria todos los patrones y los aplico en todo. 
Llevo a que todos usen patrones y se agarro superioridad sobre los 'programadores', dice que la cantidad de patrones deberian ser una medida para la reusabilidad.
Patron para aplicar patrones: 
1 For the instance variables , State pattern
2 For each method apply strategy pattern
3 For a groupong of instances, apply the chain responsabilty pattern
4 For a groupong of instances, apply the compsoite, iterator and visitor pattern.
5 for clients of objets, apply observer pattern.
6 for clients of objects, apply the proxy pattern 
7 for each hierarchy of objects, apply facade pattern
8 for legacgy objectes, apply adapter pattern
9 for creating objects as part of a family, apply the abstract factory, builder, and factoey methods pattern
10 for creating similiar objects, prototype pattern.
Final: el aplicar patron tras patron hizo que sus sistemas no sean entendibles por otros, y a la hora de hacer cambios esto no es organico en el modelo,
necesitando mas patrones para hacerlo. Se pregunta si despues de haber hecho todo esto realmente mejoro la reusabilidad, si aplicar el patron mejora la resolucion
(y que siquiera implica mejor para esto). 

Was computing dumbed down by the arrival of computer science in academia?(Alan Kay):
Al principio piensa que no pues en los 60s todo se hacia en universidades pero pocas, luego se extendio a todas las universidades prometiendo en 4 años una
carrera de grado, esto le hecha la culpa a los baby boomers y dice que se debe a que quieren ver a las universidades como mercados mas que lugares de investigacion.
Dice que las universidades se dejan llevar por hacer 'vocacion entrenada' en vez de entendimiento academico, ademas de sucumbir a presiones del mercado en 
base a necesitar cierta tecnologia y ser eso lo enseñado en vez de tener su propio criterio (las universidades) sobre que son 'ciencias de computar' y 
'practicas ingenieriles para software'. Dice que cuando estuvo en universidades no veia que se enseñara como una ciencia y resalta que no hay ni perspectiva
ni curiosidad intelectual.
Dice que no se tiene en cuenta la parte de ciencia en ciencias de la computacion y que todos lo describen mas parecido a algo de ingenieria,
Culpa a las universidades de 'atontar'(dumb down' las ciencias de la computacion cuando las universidades deberian ocuparse de no dejar que pase esto,
y culpa al mercado de ser tonto al nivel 'Dunning-kruger' (efecto en el que alguien tiene mayor estima en su conocimiento de un tema del que realmente tiene) 
y llevo esta ignorancia al publico en general, en especifico la educacion en todos sus niveles.
 Dice que en los 60s se pensaba a la cs como una aspiracion y una pregunta, en vez de algo resuelto.
Dice que en las ciencias se intenta modelar a traves de reglas (y matematica) un entendimiento del tema que permita teorizar mejor sobre el y mejorar
su entendimiento general.
Menciona que cs es la ciencia de los sistemas, todos los sistemas. Los algoritmos demas son una pequeña parte de computar, computar es entender, crear y 
construir sistemas. Menciona que a veces la matematica necesaria no esta inventada para la cs, y que en parte de descubrirla se puede usar una computadora
por eso puede pensarse que la computadora es 'meta' pues se puede usar para generar modelos de ella misma(Acordarse que en ingles es computer science)
Dice que pudieron ser creativos con xerox porque porque pensaban en 'sistemas de procesos'.
